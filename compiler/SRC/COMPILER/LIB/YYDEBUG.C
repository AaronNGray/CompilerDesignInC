/*@A (C) 1992 Allen I. Holub                                                */
#include <stdio.h>
#include <ctype.h>
#include <sys/types.h>	 /* ANSI/UNIX time functions.			*/
#include <sys/timeb.h>	 /* ANSI/UNIX time functions.			*/
#include <signal.h>	 /* Needed by signal.				*/
#include <stdarg.h>	 /* ANSI variable-argument lists.		*/
#include <io.h>		 /* Prototypes for access().	   		*/
#include <string.h>	 /* Prototypes for string functions.		*/
#include <stdlib.h>	 /* Prototypes for other library functions.	*/
#include <tools/debug.h> /* Various macros.				*/
#include <curses.h>	 /* Window functions.				*/
#include <tools/l.h>	 /* Prototypes for all of l.lib, including all	*/
			 /* functions in the current file.		*/
extern char *yytext;	 /* Generated by LeX and lex.			*/
extern int  yylineno;
extern int  yyleng;

/* If your system doesn't have an <stdarg.h>, use the following:
 *
 * typedef char *va_list;
 * #define va_start(arg_ptr,first)  arg_ptr = (va_list)&first + sizeof(first)
 * #define va_arg(arg_ptr,type)	    ((type*)(arg_ptr += sizeof(type)))[-1]
 * #define va_end()
 *----------------------------------------------------------------------
 * The following macros take care of system dependencies. They assume a 25-line
 * screen on the IBM and a 24-line screen under Unix. Code put inside an MS()
 * macro compiles only if a MSDOS compiler is being used. Code in a UNIX()
 * macro compiles only if a UNIX compiler is being used. The NEWLINE define
 * takes care of a bug in the UNIX curses package that isn't present in the
 * DOS version presented in this book (it clears the bottom line after a
 * scroll). box.h (in Appendix A) holds #defines for the IBM Box-drawing
 * characters. #define NOT_IBM_PC to use the more portable defines in that
 * file ('+' is used for corners, '|' for vertical lines, and '-' for
 * horizontal ones) rather than the less-portable IBM graphics characters.
 * fcntl() is also used only in UNIX mode.
 */

#ifdef MSDOS				/* An MSDOS compiler is active	  */
#	include <tools/box.h>		/* Use IBM-PC graphics characters */
#	define SCRNSIZE 25
#	define NEWLINE(win) (Interactive ? waddch( win, '\n') :0)
#else
#	define NOT_IBM_PC		/* Use dashes, vertical bars, etc. */
#	include <tools/box.h>
extern  int	fputc();		/* system stuff */
extern	int	errno;
#	define SCRNSIZE 24
#	define NEWLINE(win) (Interactive ? (waddch( win, '\n'), wclrtoeol(win))\
					 : 0 )
#endif

/* Prototypes for local statics: */

#if ( 0 UNIX(+1) )			/* UNIX compilers only */
    PRIVATE	void    kbready ();
    PRIVATE	WINDOW	*boxwin ();
#else
    PRIVATE	WINDOW	*boxwin (int lines, int cols, int y_start,
						 int x_start, char *title );
#endif

/* ----------------------------------------------------------------------
 * Defines for the windows. STACK_TOP is the top line of the stack window.
 * DEFSTACK is the default size of the text area of the stack window.
 * STACK_WINSIZE is the height of the stack window, including the border. IO_TOP
 * is the top line of both the I/O and comments windows, and IO_WINSIZE is the
 * height of the text area of those windows. It should use the whole screen
 * less the area used for the stack and prompt windows.
 */

#define STACK_TOP	 0
#define DEFSTACK	 11		    /* Stacksize=DEFSTACK by default. */
#define STACK_WINSIZE    (Stacksize +2)
#define PROMPT_TOP       (SCRNSIZE - 3)
#define PROMPT_WINSIZE   3
#define	IO_TOP 	    	 (STACK_WINSIZE-1)
#define IO_WINSIZE  	 ((SCRNSIZE - (STACK_WINSIZE + PROMPT_WINSIZE)) + 2)

#define TOKEN_WIDTH	22      /* Width of token window including border. */
#define PRINTWIDTH	79	/* Only this many characters are printed on each
				 * line by the write-screen (w) command. Extra
				 * characters are truncated.
				 */

#define ESC	0x1b		/* ASCII ESC character.			*/

/* ----------------------------------------------------------------------
 * Breakpoints. A breakpoint is set with a 'b' command. It causes automatic-mode
 * operation to terminate immediately before applying a specific production or
 * when a specified symbol is on the top of stack. P_breakpoint holds the
 * production breakpoint; T_breakpoint holds the top-of-stack breakpoint;
 * I_breakpoint is the input breakpoint. The former is an int because it's
 * always a number. The latter two are strings because they can be symbolic
 * names as well as numbers. The last variable, L_breakpoint, is the input-
 * line breakpoint.
 */

#define	BRKLEN 33	/* Longest lexeme recognized in a breakpoint + 1. */

PRIVATE int	P_breakpoint		= -1 ;
PRIVATE int	L_breakpoint		= -1 ;
PRIVATE char	S_breakpoint[ BRKLEN ]	= { '\0' } ;
PRIVATE char	I_breakpoint[ BRKLEN ]	= { '\0' } ;

/*----------------------------------------------------------------------
 * I've attempted to isolate these routines as much as possible from the actual
 * parser. They do need to know where all the stacks are, however. The following
 * variables are initialized at run-time by an access routine [yy_init_debug()]
 * and are used to access static variables in the parser itself. Note that the
 * addresses of the stack pointers are stored, not the contents of the stack
 * pointers.
 */

PRIVATE int	Abort    ;	      /* Force input routine to return EOI.   */
PRIVATE char	*Vstack  ;	      /* Base address of value stack (or NULL */
				      /* if called by llama-generated parser).*/
PRIVATE int	Vsize    ;	      /* Size of one element of value stack.  */
PRIVATE char    **Dstack ;	      /* Base address of debug (symbol) stack.*/
PRIVATE char	***P_dsp ; 	      /* Pointer to debug-stack pointer.      */
PRIVATE int	*Sstack	 ; 	      /* Base address of state stack.         */
PRIVATE int	**P_sp	 ; 	      /* Pointer to state-stack pointer.      */
PRIVATE int	Depth    ;	      /* Stack depth (all three stacks).      */

/*----------------------------------------------------------------------
 * The following variables are all used internally
 */

PRIVATE WINDOW	*Stack_window   ;     /* Windows for the debugging screen     */
PRIVATE WINDOW	*Prompt_window  ;
PRIVATE WINDOW	*Code_window    ;
PRIVATE WINDOW	*Comment_window ;
PRIVATE WINDOW	*Token_window   ;
PRIVATE int     Stacksize = DEFSTACK;/* Number of active lines in the stack   */
				     /*      window (doesn't include border). */
PRIVATE int  Onumele     = 0;        /* Number of elements on the stack.      */
PRIVATE int  Interactive = 1;        /* Interactive mode (not n or N).        */
PRIVATE int  Singlestep  = 1;        /* Single step through parse if true.    */
PRIVATE long Delay       = 0L;       /* Amount of time to wait after printing */
				     /* each stack update when not single     */
				     /* stepping (milliseconds).              */
PRIVATE int  Inp_fm_file  = 0;    /* 1 if input file is open.		      */
PRIVATE FILE *Log         = NULL; /* Pointer to the log file if one is open.  */
PRIVATE int  No_comment_pix = 0;  /* 1 if no comment-window output is printed.*/
PRIVATE int  No_stack_pix   = 0;  /* 1 if no stack pictures are to be printed */
				  /* 			      in the log file.*/
PRIVATE int Horiz_stack_pix = 0;  /* 1 if stack pictures are printed horiz-   */
				  /* 		     ontally in the log file. */
PRIVATE int Parse_pix;		  /* if(Horiz_stack_pix), print state stack.  */
PRIVATE int Sym_pix;		  /* if(Horiz_stack_pix), print symbol stack. */
PRIVATE int Attr_pix;		  /* if(Horiz_stack_pix), print attrib. stack.*/

#if (0 UNIX(+1) )  /*--------------- UNIX SYSTEM V ONLY --------------------*/
					/* Since MS-DOS has a system call that
					 * gives the keyboard status, detecting
					 * if a key has been pressed without
					 * reading the character is easy. In
					 * UNIX you must use SIGIO to set a
					 * flag (Char_avail). kbready() is the
					 * SIGIO exception handler.
					 */
PRIVATE int	Char_avail = 0;
#define kbhit()	Char_avail

#else   /*-------------------- MSDOS VERSION ONLY -------------------------*/

extern int    kbhit ( void );		/* Microsoft function. returns 1 if a */
					/* character is waiting to be read    */
					/* from the keyboard buffer. This     */
					/* function is provided in most	      */
					/* MS-DOS compiler's libraries.	      */

/* The Map[] array converts IBM box-drawing characters to something that's
 * printable. The corners are converted to plus signs, horizontal lines go to
 * dashes, and vertical lines map to vertical bars. The conv() subroutine is
 * passed a character and returns a mapped character. It must be a subroutine
 * because of the way that it's used below. It would have unacceptable
 * side-effects if rewritten as a macro.
 */

PRIVATE unsigned char Map[] =
{
    '|', '+', '+', '+', '+', '+', '+', '|', '+', '+', '+', '+', '+', '+',
    '+', '+', '+', '-', '+', '+', '+', '+', '+', '+', '+', '+', '=', '+',
    '+', '+', '+', '+', '+', '+', '+', '+', '+', '+', '+', '+'
};

PRIVATE	int  conv(c)
int c;
{
    return (VERT <= c && c <= UL) ?  Map[c - VERT] : c ;
}
#endif  /*--------------------------------------------------------------*/
PUBLIC	int yy_init_debug(sstack, p_sp, dstack, p_dsp, vstack, v_ele_size, depth)

int	*sstack;	/* Base address of state stack.  		  */
int	**p_sp;		/* Address of state-stack pointer.		  */
char	**dstack;	/* Address of debug stack.			  */
char	***p_dsp;	/* Address of debug-stack pointer.		  */
void	*vstack;	/* Base address of value stack or NULL for LLama. */
int	v_ele_size;	/* Size of one element of value stack.		  */
int	depth;		/* Number of elements in all three stacks.	  */
{
    /* Initialize for interactive I/O for curses. Return 1 on a successful
     * initialization, 0 otherwise.
     */

    char buf[80];

    UNIX( int flags;					   )
    UNIX( signal( SIGIO, kbready );			   )
    UNIX( flags = fcntl( fileno(stdin), F_GETFL, 0 );	   )
    UNIX( fcntl( fileno(stdin), F_SETFL, flags | FASYNC ); )

    Sstack = sstack;
    Dstack = dstack;
    Vstack = (char *) vstack;
    Vsize  = v_ele_size;
    P_sp   = p_sp;
    P_dsp  = p_dsp;
    Depth  = depth;
    Abort  = 0;


    initscr();
    signal( SIGINT, (void (*)(int)) die_a_horrible_death );

    noecho();		/* Don't echo input characters automatically.	     */
    crmode();		/* Don't buffer input.				     */
    MS( nosave(); )	/* Don't save region under windows (my curses only). */

    Stack_window   = boxwin( STACK_WINSIZE, 80, STACK_TOP, 0, "[stack]"    );
    Comment_window = boxwin( IO_WINSIZE,    40, IO_TOP,    0, "[comments]" );
    Code_window	   = boxwin( IO_WINSIZE,    41, IO_TOP,   39, "[output]"   );

    Token_window   = boxwin(PROMPT_WINSIZE, TOKEN_WIDTH, PROMPT_TOP,
					    80 - TOKEN_WIDTH, "[lookahead]" );

    Prompt_window  = boxwin(PROMPT_WINSIZE, (80 - TOKEN_WIDTH) + 1,
					    PROMPT_TOP,  0, "[prompts]"  );
    scrollok( Stack_window,   TRUE  );
    scrollok( Comment_window, TRUE  );
    scrollok( Code_window,    TRUE  );
    scrollok( Prompt_window,  TRUE  );
    scrollok( Token_window,   FALSE );

    Onumele = 0;

    while( !Inp_fm_file )
    {
	/* If you don't have an input file yet, get one. yyprompt() prints the
	 * prompt in the PROMPT window, and fills buf with the reply.
	 */

	if( !yyprompt( "Input file name or ESC to exit: ", buf, 1 ) )
	{
	    yy_quit_debug();
	    return 0;
	}
	new_input_file( buf );
    }
    delay();   			/* Wait for a command before proceeding */
    return 1;
}

/*----------------------------------------------------------------------
 * Exception handlers:
 */

#if ( 0 UNIX(+1) )		/* UNIX compilers only */
PRIVATE	void    kbready( )  /* Called when new character is available. */
{
    Char_avail = 1;
}
#endif

PRIVATE	void die_a_horrible_death()		   /* Come here on a SIGINT */
{						   /* or 'q' command.       */
    signal( SIGINT, SIG_IGN );
    yy_quit_debug();
    exit( 0 );
}

PUBLIC	void yy_quit_debug()			      /* Normal termination. */
{
    echo();				   /* Turn echo and editing back on. */
    nocrmode();
    move( 24, 0 );	      /* Put the cursor on the bottom of the screen. */
    refresh();
    endwin();					         /* Turn off curses. */

    if( Log )
	fclose( Log );

    stop_prnt();
    signal( SIGINT, SIG_DFL );
}

/*----------------------------------------------------------------------*/

PRIVATE	WINDOW	*boxwin( lines, cols, y_start, x_start, title )
int	lines;
int	cols;
int	y_start;
int	x_start;
char	*title;
{
    /* This routine works just like the newwin() except that the window has a
     * box around it that won't be destroyed by writes to the window. It
     * accomplishes this feat by creating two windows, one inside the other,
     * with a box drawn in the outer one. It prints the optional title centered
     * on the top line of the box. Set title to NULL (or "") if you don't want
     * a title. Note that all windows are made subwindows of the default window
     * to facilitate the print-screen command.
     */

    WINDOW *outer;

    outer = subwin( stdscr, lines, cols, y_start, x_start);
    box( outer, VERT, HORIZ );

    if( title && *title )
    {
	wmove  ( outer, 0, (cols - strlen(title))/2 );
	wprintw( outer, "%s", title );
    }

    wrefresh ( outer );
    return subwin( outer, lines-2, cols-2, y_start+1, x_start+1 );
}

/*----------------------------------------------------------------------*/

PUBLIC  int	yy_get_args( argc, argv )
int	argc;
char	**argv;
{
    /* Scan argv arguments for the debugging options and remove the arguments
     * from argv. Recognized arguments are:
     *
     * -sN	Set stack-window size to N lines. The size of the other windows
     *		scale accordingly. The stack window is not permitted to get so
     *		large that the other windows will disappear, however.
     *
     * The first argument that doesn't begin with a minus sign is taken to be
     * the input file name. That name is not removed from argv. All other
     * arguments are ignored and are not removed from argv, so you can process
     * them in your own program. This routine prints an error message and
     * terminates the program if it can't open the specified input file.
     * Command-line processing stops immediately after the file name is
     * processed. So, given the line:
     *
     *  	program -x -s15 -y foo -s1 bar
     *
     * Argv is modified to:
     *
     *  	program -x -y foo -s1 bar
     *
     * The file "foo" will have been opened for input and the stack window will
     * be 15 lines high. Return new value of argc that reflects the removed
     * arguments;
     */

    char  **newargv;
    char  **oldargv = argv;
    char  *filename = NULL;
    int	  ssize     = DEFSTACK;

    newargv  = ++argv;
    for( --argc; --argc >= 0; ++argv )
    {
	if( argv[0][0] != '-' )
	{
	    filename = *newargv++ = *argv;
	    break;
	}
	else if( argv[0][1] == 's' )					/* -s */
	    ssize = atoi( &argv[0][2] );      /* Don't copy to *newargv here. */
	else								/* -? */
	    *newargv++ = *argv;
    }

    Stacksize = ( ssize < 1	       )  ? DEFSTACK   :
		( ssize > (SCRNSIZE-6) )  ? SCRNSIZE-6 :
		/* ssize is in bounds */    ssize      ;

    if( filename )
    {
	/* Open input file if one was specified on the command line. */

	if( ii_newfile(filename) != -1 )
	    Inp_fm_file = 1;
	else
	{
	    perror( filename );
	    exit( 1 );
	}
    }
    return newargv - oldargv;
}

ANSI( PRIVATE int prnt_putc(int c, WINDOW *win)  )
KnR ( PRIVATE int prnt_putc(    c,         win)  )
KnR ( int c;					 )
KnR ( WINDOW *win;				 )
{
    /*    All output done through prnt_putc is suppressed in Go mode. Also note
     * that the arguments are reversed from addch(). This reversal lets you use
     * the prnt() subroutine (described in Appendix A), which expects a putc()-
     * like output function. Newlines are suppressed here so that you can have
     * more control over scrolling. Similarly, sequences of white space are
     * replaced by a single space character to conserve space in the window.
     *    Test_c is used to take care of the IBM graphics characters that form
     * the vertical line separating the stream-identification column from the
     * actual output. The c is mapped to a '|' if it's too large to be an ASCII
     * character (so isspace() will work properly).
     */

    static WINDOW *last_win = NULL;
    static int	  last_c    = 0;
    int		  test_c;

    if( Interactive && c != '\n' )
    {
	test_c = (c < 0x7f) ? c : '|';

	if( !(win==last_win && isspace(test_c) && isspace(last_c)) )
	    waddch( win, isspace(test_c) ? ' ' : c );

	last_win = win;
	last_c   = test_c;
    }
    return c;	/* keeps the compiler happy by returning a value a'la putc */
}
/*----------------------------------------------------------------------*/
#ifdef MSDOS

#    define refresh_win(win) /* empty */

#else	/* UNIX */

    PRIVATE	void refresh_win( win )
    WINDOW	*win;
    {
        /* Refresh the windows if you're not in go mode. (If you are, nothing
         * will have been written, so there's not point in doing the refresh.
         */

        if( Interactive )
	    wrefresh( win );
    }
#endif

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

PUBLIC	void yy_output( where, fmt, args )		/* Generate code */
int	where;
char	*fmt;
va_list	args;
{
    /* Works like vprintf(), but sends output to the code window. In the window,
     * it ignores any newlines in the string but prints a newline after every
     * call. All code sent to yycode(), yydata(), and yybss() is funneled
     * here. "where" should be one of the following:
     *
     *		0 : code
     *		1 : data
     *		2 : bss
     *
     * Note that if the three associated streams (yycodeout, yybssout, and
     * yydataout--all declared in the parser output file) are not directed to
     * stdout, output is sent to that stream TOO. Don't modify these to point
     * at stderr (or any other stream that accesses the console: /dev/tty, con,
     * etc.) or you'll mess up the screen.
     *
     * Note that the real yycode(), etc (ie. the ones supplied when YYDEBUG
     * is not defined) don't do anything special with newlines. In particular,
     * they are not inserted automatically at the end of the line. To make both
     * sets of routines compatible, your output strings should all have exactly
     * one newline, placed at the end of the string (don't imbed any in the
     * middle).
     */

    extern FILE	*yycodeout, *yydataout, *yybssout;

    if( Log )
    {
	fprintf( Log,    where == 0  ?  "CODE->" :
		         where == 1  ?  "DATA->" : "BSS-->" );
	prnt ( (prnt_t) fputc, Log, fmt, args );
	fputc( '\n', Log );
    }

    NEWLINE( Code_window );

    prnt_putc( where==0 ? 'C' : where==1 ? 'D' : 'B',	Code_window );
    prnt_putc( VERT,					Code_window );

    prnt( (prnt_t) prnt_putc, Code_window, fmt, args );
    refresh_win( Code_window );

    if( where == 0 && yycodeout != stdout )
	vfprintf( yycodeout, fmt, args );

    if( where == 1 && yydataout != stdout )
	vfprintf( yydataout, fmt, args );

    if( where == 2 && yybssout != stdout )
	vfprintf( yybssout, fmt, args );
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
ANSI( PUBLIC void yycomment( char *fmt, ...  )	)
KnR ( PUBLIC      yycomment(       fmt	     )	)
KnR ( char *fmt;				)
{
    /* Works like printf() except that it automatically prints a newline
     * IN FRONT OF the string and ignores any \n's in the string itself. Writes
     * into the comment window, and outputs a message to the log file if
     * logging is enabled.
     */

    va_list	  args;
    va_start( args, fmt );

    if( Log && !No_comment_pix )
	prnt( (prnt_t) fputc, Log, fmt, args );

    NEWLINE( Comment_window );
    prnt( (prnt_t) prnt_putc, Comment_window, fmt, args );
    refresh_win( Comment_window );
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

ANSI( PUBLIC void yyerror( char *fmt, ...  )	)
KnR ( PUBLIC      yyerror(       fmt	   )	)
KnR ( char *fmt;				)
{
    /* Debugging version of the error routine. Works just like the nondebugging
     * version, but writes to the comment window. Note that yycomment() copies
     * the error message to the Log file. Interactive mode is temporarily
     * enabled to assure that error messages get printed.
     */

    int	     old_interactive;
    va_list  args;
    va_start( args, fmt );

    old_interactive = Interactive;
    Interactive     = 1;

    yycomment( "ERROR, line %d near <%s>\n", yylineno, yytext );

    if( Log )
	prnt( (prnt_t) fputc, Log, fmt, args );

    NEWLINE	( Comment_window );
    prnt	( (prnt_t) prnt_putc, Comment_window, fmt, args );
    refresh_win	( Comment_window );

    Interactive = old_interactive;
    Singlestep  = 1;			/* Force a breakpoint */
    yy_pstack( 0, 1 );
}

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

ANSI( PUBLIC void yy_input( char *fmt, ...  )	)
KnR ( PUBLIC      yy_input(       fmt	     )	)
KnR ( char *fmt;				)
{
    /* This is not an input function; rather, it writes to the INPUT window.
     * It works like printf(). Note that nothing is logged here. The logging
     * is done in nextoken(). Ignores all \n's in the input string.
     */

    va_list	  args;
    va_start( args, fmt );
    prnt( (prnt_t) prnt_putc, Prompt_window, fmt, args );
    refresh_win( Prompt_window );
}

/*----------------------------------------------------------------------*/

PRIVATE	void display_file( name, buf_size, print_lines )
char	*name;			   /* Initially holds the file name, but */
int     buf_size;		   /*       recycled as an input buffer. */
int	print_lines;
{
    /* Display an arbitrary file in the stack window, one page at a time.
     * The stack window is not refreshed by this routine.
     */

    FILE  *fd;
    int	  i;
    int	  lineno = 0;

    if( !(fd = fopen( name, "r")) )
    {
	NEWLINE  ( Prompt_window 			);
	wprintw  ( Prompt_window, "Can't open %s",  name );
	wrefresh ( Prompt_window 			);
	presskey ();
    }
    else		    /* Note that order of evaluation is important in  */
    {			    /* the following while statement. You don't want  */
			    /* to get the line if i goes past 0.	      */

	for( i = Stacksize-1 ;; i = (*name == ' ') ? 1 : Stacksize - 2 )
	{
	    while(  --i >= 0  &&  fgets(name, buf_size, fd) )
	    {
		if( print_lines )
		    wprintw( Stack_window, "%3d:", ++lineno );

		wprintw ( Stack_window, "%s", name );
		wrefresh( Stack_window );
	    }

	    if( i > 0 )
		break;

	    if(!yyprompt("ESC quits. Space scrolls 1 line. Enter for screenful",
								    name, 0) )
		break;
	}
	yyprompt("*** End of file. Press any key to continue ***", name, 0 );
	fclose( fd );
    }
}

/*----------------------------------------------------------------------*/

PRIVATE	void write_screen( filename )
char	*filename;
{
    /* Print the current screen contents to the indicated file. Note that the
     * right edge of the box isn't printed in order to let us have 79-character
     * lines. Otherwise, the saved screen shows up as double-spaced on most
     * printers. The screen image is appended to the end of the file. In MS-DOS,
     * Use "prn:" as the file name if you want to go to the printer.
     *
     * Syserrlist and errno are both defined in <stdlib.h>
     */

    char	buf[2];
    char	*mode = "a";
    int		row, col, y, x;
    FILE	*file;

    if( access( filename, 0 ) == 0 )
	if( !yyprompt("File exists, overwrite or append? (o/a): ", buf, 0) )
	{
	    NEWLINE ( Prompt_window 	  );
	    yy_input( "Aborting command." );
	    presskey();
	    return;
	}
	else
	{
	    if( toupper(*buf) == 'O' )
		mode = "w";
	}

    if( file = fopen( filename, mode) )
	yy_input("...%s %s...",
		    *mode=='w' ? "overwriting" : "appending to", filename );
    else
    {
	yy_input( "Can't open %s.", filename );
  	MSC( yy_input( "(%s)", sys_errlist[errno]);	)
	presskey();
	return;
    }

    getyx( Prompt_window, y, x );

    for( row = 0; row < SCRNSIZE; row++ )
    {
	for( col = 0; col < PRINTWIDTH; col++ )
	{
	    MS  ( fputc( conv( mvinch(row,col) ), file );	)
	    UNIX( fputc(       mvinch(row,col)  , file );	)
	}

	fputc( '\n', file );
    }

    fclose( file );
    wmove( Prompt_window, y, x );
}
PUBLIC	void yy_pstack( do_refresh, print_it )

int	do_refresh;		/* redraw entire window rather than update  */
int	print_it;		/* if true, print the stack to the log file */
{
    /* Print the state, debug, and value stacks.
     *
     * The library routine yypstk() (which returns an empty string by default)
     * is called to print value stack items. It should return a pointer to a
     * string that represents the value-stack contents. Just provide a similarly
     * named routine to print your real value stack. The LLAMA parser passes
     * garbage to yypstk(), so use the default routine in LLAMA. The OCCS parser
     * passes yypstk() a pointer to a value-stack item and it should return a
     * pointer to a string representing attributes of interest. The line should
     * not contain any newlines and it should be at most 58 characters long.
     * If do_refresh is true, the entire stack window is redrawn, otherwise
     * only those parts of the window that have been changed are modified.
     */

    int 	  numele            ;   /* # of elements on the stack	     */
    int	          *toss 	    ;   /* top of state stack	    	     */
    char	  **tods	    ;   /* top of debug stack		     */
    char	  *tovs	    	    ;   /* top of value stack		     */
    int  	  *state  	    ;   /* current state-stack pointer	     */
    char 	  **debug  	    ;   /* current debug-stack pointer	     */
    char	  *value	    ;   /* current value-stack pointer	     */
    int		  width		    ;   /* Width of column in horiz. stack   */
    static int	  times_called = -1 ;   /* # of times this subroutine called */
    char	  *p		    ;
    int		  i		    ;

    state  = *P_sp;
    debug  = *P_dsp;
    numele = Depth - (state - Sstack);
    value  = (Vstack + (Depth - numele) * Vsize);

    if( Log && !No_stack_pix && print_it )
    {
	/* Print the stack contents out to the log file.  */

	if( !Horiz_stack_pix )
	{
	    fprintf(Log, "   +---+------------------+\n");
	    if( numele <= 0 )
		fprintf( Log," * | * |   ************   |   Stack is empty.\n");
	    else
	    {
		toss = state;
		tods = debug;
		tovs = value;
		for(i = numele; --i >= 0; ++toss, ++tods, tovs += Vsize )
		    fprintf( Log, "%3d|%3d| %16.16s | %1.52s\n",
			       toss - state, *toss, *tods, yypstk(tovs, *tods));
	    }
	    fprintf(Log, "   +---+------------------+\n");
	}
	else
	{
	    if( state < Sstack )
		fprintf( Log,"*** Stack empty ***\n");
	    else
	    {
		/* Print horizontal stack pictures. Note that you have to go
		 * through the stack from bottom to top to get the top-of-stack
		 * element on the right.
		 */

		for( i = 0; i <= 2; ++i )
		{
		    if( !Parse_pix && i == 0 ) continue;
		    if( !Sym_pix   && i == 1 ) continue;
		    if( !Attr_pix  && i == 2 ) continue;

		    switch( i )
		    {
		    case 0: fprintf( Log, "   PARSE  " ); break;
		    case 1: fprintf( Log, "   SYMBOL " ); break;
		    case 2: fprintf( Log, "   ATTRIB " ); break;
		    }

		    toss = Sstack +  (Depth - 1);
		    tods = Dstack +  (Depth - 1);
		    tovs = Vstack + ((Depth - 1) * Vsize);

		    for(; toss >= state; --toss, --tods, tovs -= Vsize )
		    {
			/* Find width of the column. I'm assuming that the
			 * numbers on the state stack are at most 3 digits
			 * long, if not, change the 3, below.
			 */

		        p     = yypstk( tovs, *tods );
			width = 3;

			if( Sym_pix  ) width = max( width, strlen(*tods) );
			if( Attr_pix ) width = max( width, strlen(p)     );

			switch( i )
			{
			case 0: fprintf( Log, "%-*d ", width, *toss ); break;
			case 1: fprintf( Log, "%-*s ", width, *tods ); break;
			case 2: fprintf( Log, "%-*s ", width, p     ); break;
			}
		    }

		    fputc( '\n', Log );
		}
	    }
	}
    }

    if( !Interactive )
    {
	if( ++times_called % 25 == 0 )
	{
	    wprintw ( Stack_window, "working: %d\r", times_called );
	    wrefresh( Stack_window );
	}
	return;
    }

    if( *S_breakpoint  &&  state < Sstack + Depth )

    {
	/* Break if the breakpoint is a digit and the top-of-stack item has that
	 * value, or if the string matches the string currently at the top of
	 * the symbol stack.
	 */

	if( isdigit(*S_breakpoint)  )
	{
	    if( atoi(S_breakpoint) == *state )
		Singlestep = 1;
	}
	else if( !strcmp(S_breakpoint, *debug) )
		Singlestep = 1;
    }

    if( do_refresh )
	yy_redraw_stack();			      /* Redraw entire stack */

    else if( numele > Onumele )
    {
	/* The stack has grown. Redraw only those parts of the stack that have
	 * changed. (I'm assuming only by one element.) The main difficulty
	 * here is that only the top few elements of a large stack are
	 * displayed. Consequently, the stack window may have to scroll up
	 * or down a line if the stack size is hovering around the window size.
	 * There's no portable way to scroll the window up under UNIX curses, so
	 * we have to redraw the stack to scroll up in this situation. We'll
	 * overwrite the top element with itself by the wprintw() call, but
	 * that's no big deal, and it simplifies the code.
	 */

	if( numele > Stacksize )	/* scroll down, opening up top line */
	{
	    MS  ( wscroll( Stack_window, -1 ); 	)
    	    UNIX( yy_redraw_stack(); 		)

	    wmove( Stack_window, 0, 0 );
	}
	else
	    wmove( Stack_window, Stacksize - numele, 0 );

	wprintw( Stack_window, "%3d%c %16.16s %c %1.52s",
			    *state, VERT, *debug, VERT, yypstk(value, *debug) );
	wrefresh( Stack_window );
    }
    else
    {
	/* The stack has shrunk, perhaps by several elements. Remove them one at
	 * a time. (It's too confusing if several elements disappear from the
	 * stack at once. It's best to watch them go one at a time.) If the
	 * number of elements on the stack (i) is greater than the window size,
	 * you can pop an element by scrolling up and then writing in a new
	 * bottom line, otherwise, just go to the correct line and erase it.
	 * Do a refresh after each pop.
	 */

	for( i = Onumele; i > numele; --i )
	{
	    if( i > Stacksize )
	    {
		/* Do a pop by scrolling up, the easiest way to scroll is to
		 * move to the right edge of the bottom line and then issue
		 * a newline. After the scroll, overwrite the now-blank bottom
		 * line with the appropriate stack information. The involved
		 * expression that is the first argument to yypstk is doing:
		 *	     (Vstack + Depth)[ -i + Stacksize ]
		 * It must do the pointer arithmetic explicitly, however, by
		 * multiplying by the size of one value-stack item (Vsize).
		 */

		wmove   ( Stack_window, Stacksize-1, 77		);
		NEWLINE ( Stack_window 				);
		wprintw ( Stack_window, "%3d%c %16.16s %c %1.52s",
			(Sstack + Depth)[ -i + Stacksize ], VERT,
			(Dstack + Depth)[ -i + Stacksize ], VERT,
			yypstk( (Vstack + (Depth*Vsize)) +
					((-i + Stacksize) * Vsize),
					(Dstack + Depth)[ -i + Stacksize ] )
			);
	    }
	    else
	    {
		wmove    ( Stack_window, Stacksize - i, 0 );
		wclrtoeol( Stack_window			  );
	    }
	    wrefresh( Stack_window );
	}
    }
    delay();
    wrefresh( Stack_window );
    Onumele = numele;
}

/*----------------------------------------------------------------------*/

PUBLIC	void yy_redraw_stack()
{
    /* Redraw the entire stack screen by writing out the top Stacksize elements
     * of the stack in the stack window. Note that scrolling is turned off so
     * that the screen won't scroll when you print the last line. Unlike
     * yy_pstack(), this routine won't pause for a command.
     */

    int	 i;
    int  numele;			   /* Number of elements on the stack */
    int  *state  = *P_sp;		   /* Pointer to top of state stack   */
    char **debug = *P_dsp;		   /* Pointer to top of debug stack   */
    char *value;		   	   /* Pointer to top of value stack   */

    werase   ( Stack_window );
    scrollok ( Stack_window, FALSE );

    numele =  Depth - (state - Sstack);
    value  =  Vstack + ((Depth - numele) * Vsize);

    wmove( Stack_window, numele <= Stacksize ? Stacksize - numele : 0, 0 );

    for( i=min(Stacksize, numele); --i >= 0;  ++state, ++debug, value += Vsize )
	wprintw( Stack_window, "%3d%c %16.16s %c %1.52s\n",
					*state, VERT,
					*debug, VERT, yypstk(value, *debug) );

    scrollok( Stack_window, TRUE );
}
PRIVATE	void delay()
{
    /* Print a prompt and wait for either a carriage return or another command.
     * Note that the time returned by time() is the elapsed time, in seconds,
     * from 00:00:00, January 1, 1970 GMT. Since there are roughly 31,557,600
     * seconds in a year (365.25 * 24 * 60 * 60) and the largest (signed)
     * 32-bit long int can hold 2,147,483,647, the time won't roll over until
     * January 18, 2038 at 2:56:02 A.M. Don't use this program on January 18,
     * 2038 at 2:56:02 A.M.
     */

    long	 start, current;
    char	 buf[80];
    int	 	 print_lines;
    struct timeb time_buf;		/* defined in sys/timeb.h */

    if( !Interactive )			/* n command (noninteractive) issued */
	return;

    if( !Singlestep && kbhit() )
    {
	/* If we're not single stepping (a 'g' command has been issued) and
	 * there's a key pressed, stop single stepping and get the character.
	 */
	input_char();
	Singlestep = 1;
    }

    if( !Singlestep )
    {
	/* If we're still doing a go command (no key was found in the previous
	 * if statement), then delay for a while. Must use two if statements
	 * here because we don't want to delay if we've just stopped go-ing.
	 * If a key is hit while we're delaying, stop looping immediately and
	 * revert back to single-step mode.
	 */

	ftime( &time_buf );
	start   = (time_buf.time * 1000) + time_buf.millitm;

	while( 1 )
	{
	    ftime( &time_buf );
	    current = (time_buf.time * 1000) + time_buf.millitm;

	    if( current - start >= Delay )
		break;

	    if( kbhit() )		/* If a key is hit, stop delaying */
	    {				/* and revert back to single-step */
		input_char();		/* mode.			  */
		Singlestep = 1;
		break;
	    }
	}
	if( !Singlestep )	/* If we're still not single stepping, then   */
	    return;		/* we're done (don't get a command), 	      */
				/* otherwise, fall out of this block and      */
				/* enter the command loop, below.	      */
    }

    while( 1 )
    {
	yyprompt( "Enter command (space to continue, ? for list): ", buf, 0 );

	switch( *buf )
	{
	case '\0' :
	case ' '  :
	case '\n' :					/* singlestep	*/
	    goto outside;

	case '?' :					/* help		*/
	    cmd_list();
	    NEWLINE ( Prompt_window );
	    presskey();
	    yy_redraw_stack();
	    break;

	case 'a':					/* abort	*/
	    Abort = 1;
	    Singlestep = 0;
	    goto outside;

	case 'b':					/* breakpoints   */
	    breakpoint();
	    yy_redraw_stack();
	    break;

	case 'd':					/* set delay time */

	    if(yyprompt("Delay time (in seconds, CR=0, ESC cancels): ", buf,1))
		Delay = (long)( atof(buf) * 1000.0 );
	    break;

	case 'f':					/* read file */

	    if( !yyprompt( "Print line numbers? (y/n, CR=y, ESC cancels): ",
									buf, 0))
		break;

	    print_lines = *buf != 'n';
	    if( !yyprompt( "File name or ESC to cancel: ", buf, 1) )
		break;

	    werase( Stack_window );
	    display_file( buf, sizeof(buf), print_lines );
	    yy_redraw_stack();
	    break;

	case 'g':						/* go!  */
	    Singlestep = 0;
	    goto outside;

	case 'i':
	    if( yyprompt( "Input file name or ESC to cancel: ", buf, 1 ) )
		new_input_file( buf );
	    break;

	case 'l':					/* enable logging */
	    to_log( buf );
	    break;

	case 'N':				/* noninteractive w/o logging */
	    Log	     	 = NULL;
	    No_stack_pix = 1;
	    Interactive  = 0;
	    Singlestep   = 0;
	    Delay        = 0L;
	    werase( Stack_window );
	    goto outside;

	case 'n':				/* noninteractive mode w/ log */
	    if( !Log  &&  !to_log(buf) )
		break;
	    Interactive = 0;
	    Singlestep  = 0;
	    Delay       = 0L;
	    werase( Stack_window );
	    goto outside;

	case 'q':				/* exit to operating system */
	    raise( SIGINT );			/* as if Ctrl-C was entered */
	    exit(0);

	case 'r':				/* redraw the stack window */
	    yy_redraw_stack();
	    break;

	case 'w':				/* write screen to file */
	    if( yyprompt( "Output file name or ESC to cancel: ", buf, 1) )
		write_screen( buf );
	    break;

	case 'x':					/* show lexemes */
	    yycomment( "current  [%0.*s]\n", yyleng,       yytext     );
	    yycomment( "previous [%0.*s]\n", ii_plength(), ii_ptext() );
	    break;

	case 0x01: yyhook_a(); break;	 /* Ctrl-A debugger hook (see text) */
	case 0x02: yyhook_b(); break;	 /* Ctrl-B			    */

	default:
	    yyprompt( "Illegal command, press any key to continue", buf, 0 );
	    break;
	}
    }
outside:
    werase  ( Prompt_window );
    wrefresh( Prompt_window );
}

/*----------------------------------------------------------------------*/

PRIVATE void cmd_list()
{
    /* Print a list of commands in the stack window & prompt for an action. */

    werase   (Stack_window );
    wmove    (Stack_window, 0, 0 );
    wprintw  (Stack_window, "a  (a)bort parse by reading EOI    \n");
    wprintw  (Stack_window, "b  modify or examine (b)reakpoint  \n");
    wprintw  (Stack_window, "d  set (d)elay time for go mode    \n");
    wprintw  (Stack_window, "f  read (f)ile                     \n");
    wprintw  (Stack_window, "g  (g)o (any key stops parse)      \n");
    wprintw  (Stack_window, "i  change (i)nput file             \n");
    wmove    (Stack_window, 0, 39 );
    wprintw  (Stack_window, "l  (l)og output to file");
    wmove    (Stack_window, 1, 39 );
    wprintw  (Stack_window, "n  (n)oninteractive mode");
    wmove    (Stack_window, 2, 39 );
    wprintw  (Stack_window, "q  (q)uit (exit to dos)");
    wmove    (Stack_window, 3, 39 );
    wprintw  (Stack_window, "r  (r)efresh stack window");
    wmove    (Stack_window, 4, 39 );
    wprintw  (Stack_window, "w  (w)rite screen to file or device\n");
    wmove    (Stack_window, 5, 39 );
    wprintw  (Stack_window, "x  Show current and prev. le(X)eme\n");
    wmove    (Stack_window, 7, (78-29)/2 );
    wprintw  (Stack_window, "Space or Enter to single step" );
    wrefresh (Stack_window );
}
PUBLIC	int yy_nextoken()
{
    /* Input a token from yylex() and echo to both the token and comment
     * windows. Yy_comment() writes to the log file too. Break if the input
     * breakpoint is set and the required token has just been read. The token
     * name is centered in the token window if it's short enough. It's
     * truncated at TOKEN_WIDTH characters otherwise.
     */

    static int 	tok = -1;		/* current token */
    char	*str;
    char	*lexeme;
    char	buf[ TOKEN_WIDTH ];
    extern char *Yy_stok[]; 		/* Generated by occs and llama */
    extern int  yylex P(( void ));

    if( tok >= 0 && (Interactive || Log) )
	yycomment( "Advance past %s\n", Yy_stok[tok] );

    lexeme = ((tok = Abort ? 0 : yylex()) == 0) ? "" : yytext;

    if( Interactive || Log )
	yycomment( "Read %s <%s>\n", str = Yy_stok[tok], lexeme );

    if( Interactive )
    {
			/* clear, then update, the token window */

	concat( TOKEN_WIDTH, buf, str, " ", lexeme, NULL );
        scrollok( Token_window,   TRUE  );
	NEWLINE ( Token_window 		);
        scrollok( Token_window,   FALSE );
	wprintw ( Token_window, "%0.*s", TOKEN_WIDTH - 2, buf );
	wrefresh( Token_window );

	if( L_breakpoint != -1  &&  L_breakpoint <= yylineno )
	{
	    L_breakpoint = -1;
	    Singlestep   =  1;
	    yy_pstack( 0, 1 );
	}
	else if( ( *I_breakpoint &&
	           (    ( isdigit(*I_breakpoint) && tok == atoi(I_breakpoint) )
		     || !strcmp( lexeme,	I_breakpoint)
	 	     || !strcmp( Yy_stok[tok],	I_breakpoint)
	           )
	         )
	       )
	{
	    Singlestep = 1;
	    yy_pstack( 0, 1 );
	}
    }

    delay();
    return tok;
}

/*----------------------------------------------------------------------*/

PUBLIC	void yy_break( production_number )
int  production_number;
{
    /*  Handles production-number breakpoints. If a break is required, start
     *  single stepping and print the stack. Stack breakpoints are handled in
     *  yy_pstack and input breakpoints are done in yy_nextoken().
     *
     *  If production_number == -1, a break is forced regardless of the value
     *  of P_breakpoint;
     */

    if( production_number == P_breakpoint || production_number == -1 )
    {
	Singlestep = 1;
	yy_pstack( 0, 1 );
    }
}

/*----------------------------------------------------------------------*/

PRIVATE int breakpoint()
{
    /* Set up a breakpoint by prompting the user for any required information.
     * Return true if we have to redraw the stack window because a help screen
     * was printed there.
     */

    int	 	type;
    char 	**p;
    char	buf[80];
    int  	rval    = 0;
    static char	*text[] =
    {
	"Select a breakpoint type (i,l,p,or s) or command (c or l):",
	"Type: Description:           Enter breakpoint as follows:",
	" i    input.....................number for token value",
	"                             or string for lexeme or token name",
	" l    input line read...........line number",
	" p    reduce by production......number for production number",
	" s    top-of-stack symbol.......number for state-stack item",
	"                             or string for symbol-stack item",
	" c = clear all breakpoints",
	" d = display (list) all breakpoints",
	NULL
    };

    if( !yyprompt("Enter type or command, ? for help, ESC aborts: ", buf,0) )
	return 1;

    if( *buf == '?' )
    {
	rval = 1;
	werase   (Stack_window);
	wmove    (Stack_window, 0, 0);

	for( p = text; *p; p )
	    wprintw(Stack_window, "%s\n", *p++ );

	wrefresh (Stack_window);
	if( !yyprompt("Enter breakpoint type or command, ESC aborts: ", buf,0))
	    return rval;
    }

    if( (type = *buf)  == 'p' )
    {
	if( yyprompt("Production number or ESC to cancel: ", buf, 1 ))
	{
	    if( !isdigit( *buf ))
		yyprompt("Must be a number, press any key to continue.", buf,0);
	    else
		P_breakpoint = atoi( buf );
	}
    }
    else if( type == 'l' )
    {
	if( yyprompt("Input line number or ESC to cancel: ", buf, 1 ))
	    L_breakpoint = atoi( buf );
    }
    else if( type == 'i' || type == 's' )
    {
	if( yyprompt("Symbol value or ESC to cancel: ", buf, 1 ))
	    strncpy( type == 'i' ? I_breakpoint : S_breakpoint, buf, BRKLEN );
    }
    else
    {
	switch( type )
	{
	case 'c':
		P_breakpoint  = -1;
		L_breakpoint  = -1;
		*S_breakpoint = 0;
		*I_breakpoint = 0;
		break;

	case 'd':
		rval = 1;
		werase (Stack_window);
		wmove  (Stack_window, 0, 0);

		wprintw(Stack_window,
		     P_breakpoint == -1 ? "Production = none\n"
					: "Production = %d\n", P_breakpoint);

		wprintw(Stack_window, "Stack      = %s\n",
					*S_breakpoint ? S_breakpoint : "none" );

		wprintw(Stack_window, "Input      = %s\n",
					*I_breakpoint ? I_breakpoint : "none" );
		wprintw(Stack_window,
		     I_breakpoint == 0	? "Input line = none\n"
					: "Input line = %d\n", I_breakpoint);
		wrefresh(Stack_window);
		NEWLINE (Prompt_window);
		presskey();
		break;

	default:
		yyprompt("Illegal command or type, Press any key.", buf, 0);
		break;
        }
    }

    return rval;
}
PRIVATE	int	new_input_file( buf )
char	*buf;
{
    /* Open up a new input file. Input must come from a file because the
     * keyboard is used to get commands. In theory, you can use both standard
     * input and the keyboard (by opening the console as another stream), but I
     * had difficulties doing this in a portable way, and eventually gave up.
     * It's not that big a deal to require that test input be in a file.
     */

    NEWLINE(  Prompt_window );
    wrefresh( Prompt_window );

    if( ii_newfile( buf ) != -1 )
	Inp_fm_file = 1;
    else
    {
	wprintw(Prompt_window, "Can't open %s.", buf );
	presskey();
    }
    return Inp_fm_file;
}

/*----------------------------------------------------------------------*/

PRIVATE  FILE	*to_log( buf )
char	*buf;
{
    /* Set up everything to log output to a file (open the log file, etc.). */

    if( !yyprompt("Log-file name (CR for \"log\", ESC cancels): ", buf,1) )
	return NULL;

    if( !*buf )
	strcpy( buf, "log" );

    if( !(Log = fopen( buf, "w")) )
    {
        NEWLINE(Prompt_window );
	wprintw(Prompt_window, "Can't open %s", buf );
	presskey();
	return NULL;
    }

    if( !yyprompt("Log comment-window output? (y/n, CR=y): ", buf,0) )
	return NULL;
    else
	No_comment_pix = (*buf == 'n');

    if( !yyprompt( "Print stack pictures in log file? (y/n, CR=y): ",buf,0) )
	return NULL;

    if( !(No_stack_pix = (*buf == 'n')) )
    {
	if( !yyprompt( "Print stacks horizontally? (y/n, CR=y): ",buf,0) )
	    return NULL;

	if( Horiz_stack_pix = (*buf != 'n') )
	{
	    if( !yyprompt("Print SYMBOL stack (y/n, CR=y): ",buf,0) )
		return NULL;
	    Sym_pix = (*buf != 'n');

	    if( !yyprompt("Print PARSE  stack (y/n, CR=y): ",buf,0) )
		return NULL;
	    Parse_pix = (*buf != 'n');

	    if( !yyprompt("Print VALUE  stack (y/n, CR=y): ",buf,0) )
		return NULL;
	    Attr_pix = (*buf != 'n');
	}
    }
    return Log;
}

/*----------------------------------------------------------------------*/

PRIVATE	int  input_char( ANSI(void) )	  /* void argument illegal under UNIX */
{
    /* Get a character from the input window and echo it explicitly. If we've
     * compiled under Unix, reset the character-available flag.
     */

    int c;

    if( (c = wgetch(Prompt_window) & 0x7f) != ESC )
	waddch( Prompt_window, c );

    UNIX( Char_avail = 0; )
    return c;
}

/*----------------------------------------------------------------------*/

PUBLIC int yyprompt( prompt, buf, getstring )
char *prompt, *buf;
int  getstring;	   /* get entire string (as compared to a single character */
{
    /* Print a prompt and then wait for a reply, load the typed characters into
     * buf. ^H (destructive backspace) is supported. An ESC causes yyprompt()
     * to return 0 immediately, otherwise 1 is returned. The ESC is not put
     * into the buffer. If "getstring" is true, an entire string is fetched and
     * prompt returns when the newline is typed. If "getstring" is false, then
     * one character is fetched and yyprompt() returns immediately after getting
     * that character. Leading and trailing white space is stripped from the
     * line if getstring is true. (You can get a single space character if it's
     * false, however.)
     */

    register int  c;
    int		  y, x;
    char	  *startbuf = buf;

    NEWLINE ( Prompt_window		  );
    wprintw ( Prompt_window, "%s", prompt );
    wrefresh( Prompt_window		  );

    if( !getstring )
	c = *buf++ = input_char();
    else
    {
	while( (c = input_char()) != '\n'  &&  c != ESC )
	{
	    if( isspace(c) && buf==startbuf )
		continue;			/* skip leading white space */

	    if( c != '\b' )
	    	*buf++ = c;
	    else			   /* handle destructive backspace */
	    {
		getyx( Prompt_window, y, x );

		if( buf <= startbuf )
		    wmove ( Prompt_window, y, x+1 );
		else
		{
		    waddch( Prompt_window, ' '  );
		    wmove ( Prompt_window, y, x );
		    --buf;
		}
	    }
	    wrefresh( Prompt_window );
	}

	while( isspace( buf[-1] )  &&  buf > startbuf )
	    --buf;		/* Strip trailing white space */
    }
    *buf = 0;
    return (c != ESC);
}

/*----------------------------------------------------------------------*/

PRIVATE	void presskey()
{
    /* Ask for a key to be pressed and wait for it.  Note that this command
     * does a refresh, but it intentionally does not clear the window before
     * printing the prompt.
     */

    wprintw ( Prompt_window, " Press any key: " );
    wrefresh( Prompt_window );
    input_char();
}
